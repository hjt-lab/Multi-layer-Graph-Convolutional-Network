import random
import scipy.io as sio
import scipy.sparse as sp
import numpy as np


# symmetrically normalize adjacency matrix
def normalize_adj(adj):
    adj = adj + sp.eye(adj.shape[0])#A^
    adj = sp.coo_matrix(adj)#A^+I
    rowsum = np.array(adj.sum(1))#D
    d_inv_sqrt = np.power(rowsum, -0.5).flatten()#L
    d_inv_sqrt[np.isinf(d_inv_sqrt)] = 0.
    d_mat_inv_sqrt = sp.diags(d_inv_sqrt)
    return adj.dot(d_mat_inv_sqrt).transpose().dot(d_mat_inv_sqrt).A


# Construct feed dictionary
def construct_feed_dict(x, a, t, b, learning_rate, momentum, placeholders):
    feed_dict = dict()
    feed_dict.update({placeholders['x']: x})
    feed_dict.update({placeholders['a']: a})
    feed_dict.update({placeholders['t']: t})
    feed_dict.update({placeholders['batch_index']: b})
    feed_dict.update({placeholders['lr']: learning_rate})
    feed_dict.update({placeholders['mom']: momentum})
    feed_dict.update({placeholders['num_features_nonzero']: x[1].shape})
    return feed_dict

def pad_adjlist(x_data):
    # Get lengths of each row of data
    lens = np.array([len(x_data[i]) for i in range(len(x_data))])

    # Mask of valid places in each row
    mask = np.arange(lens.max()) < lens[:, None]

    # Setup output array and put elements from data into masked positions
    padded = np.zeros(mask.shape)
    for i in range(mask.shape[0]):
        padded[i] = np.random.choice(x_data[i], mask.shape[1])
    padded[mask] = np.hstack((x_data[:]))
    return padded
